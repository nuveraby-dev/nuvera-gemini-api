from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import json

# Импорты для Gemini
from google import genai
from google.genai.types import Part

# Импорт конфигурации
# Убедитесь, что 'data_config.py' лежит рядом с 'app.py'
from data_config import get_price_json_string

# -----------------------------------------------------------------
# 1. КОНФИГУРАЦИЯ И ИНИЦИАЛИЗАЦИЯ
# -----------------------------------------------------------------

app = Flask(__name__)
# Установка CORS для разрешения запросов с вашего домена
CORS(app) 

# Получение API ключа из переменных окружения Vercel
API_KEY = os.environ.get("GEMINI_API_KEY")

client = None
if API_KEY:
    try:
        # Инициализация клиента Gemini
        client = genai.Client(api_key=API_KEY)
    except Exception as e:
        print(f"Ошибка инициализации клиента Gemini: {e}")

# -----------------------------------------------------------------
# 2. СИСТЕМНЫЙ ПРОМПТ И ДАННЫЕ
# -----------------------------------------------------------------

# !!! Вставьте СЮДА ваш полный и актуальный системный промпт !!!
SYSTEM_PROMPT = (
    "Ты — ведущий технолог-полиграфист и автоматизированная система консультаций типографии «Быстрая Печать». "
    "Твой тон: профессиональный, деловой и вежливый. Общение должно быть строго по факту запроса, "
    "но с использованием нейтральных, доброжелательных конструкций. "
    "Твоя задача — давать исчерпывающие, технически точные ответы, опираясь на всю полиграфическую теорию и прикрепленные данные. "
    "ВАЖНОЕ ПРАВИЛО: ВСЕ ЦЕНЫ В ПРАЙС-ЛИСТЕ УКАЗАНЫ В БЕЛОРУССКИХ РУБЛЯХ (BYN). Валюта BYN обязательна в ответах о цене. "
    "ПРИОРИТЕТНОЕ ПРАВИЛО РАСЧЕТА ЛАМИНАЦИИ: Стоимость ламинации берется за единицу измерения, вне зависимости от того, на скольких сторонах она выполняется. Стоимость ламинации НЕ ДОЛЖНА удваиваться. "
    "ПРИОРИТЕТНОЕ ПРАВИЛО РАСЧЕТА РЕЗКИ: Стоимость резки рассчитывается по количеству фактических проходов (резов), необходимых для получения конечного формата. Расчет базируется на привязке к количеству листов: 20 листов А3 = 4 реза, 40 листов А3 = 8 резов. "
    "ЗАПРЕТЫ: ЗАПРЕЩЕНО задавать встречные вопросы, напоминать о требованиях или предлагать альтернативы, если они прямо не следуют из расчета. Разрешено использовать вежливые обороты (\"Добрый день\", \"Спасибо за обращение\", \"Всегда к вашим услугам\")."
    # Добавьте сюда остальные правила и контекст!
)

# Прайс-лист в виде строки
PRICE_LIST_STRING = get_price_json_string()

# -----------------------------------------------------------------
# 3. ОБРАБОТКА ЗАПРОСОВ
# -----------------------------------------------------------------

@app.route('/api/ai_chat', methods=['POST'])
def ai_chat_endpoint():
    # Проверка, инициализирован ли клиент (наличие API ключа)
    if client is None:
         return jsonify({
            "manager_alert": True,
            "response": "Ошибка конфигурации сервера: API ключ не найден или недействителен."
        }), 500

    try:
        data = request.get_json()
        message = data.get('message')
        # history - это предыдущие сообщения, переданные с фронтенда
        history = data.get('history', [])
        
        if not message:
            return jsonify({"response": "Пустой запрос.", "status": "error"}), 400
        
        # 1. Сборка нового сообщения пользователя (user_content)
        # ИСПРАВЛЕНИЕ ОШИБКИ 500: Part.from_text() принимает только 1 аргумент
        user_content = {
            "role": "user",
            "parts": [Part.from_text(message)] 
        }
        
        # 2. Добавление системного промпта и прайс-листа в начало истории
        # Это должно быть первым сообщением (роль 'user'), чтобы настроить модель
        system_and_price_content = {
            "role": "user",
            "parts": [
                Part.from_text(SYSTEM_PROMPT),
                Part.from_text(f"ПРИКРЕПЛЕННЫЙ ПРАЙС-ЛИСТ (JSON):\n{PRICE_LIST_STRING}")
            ]
        }
        
        # Полная история для API: Системный промпт + Предыдущие сообщения + Текущее сообщение
        contents_for_api = [system_and_price_content] + history + [user_content]

        # 3. Вызов API
        response = client.models.generate_content(
            model='gemini-2.5-flash',
            contents=contents_for_api
        )
        
        # 4. Сборка успешного ответа
        ai_response = response.text
        return jsonify({"response": ai_response, "status": "ok"}), 200

    except Exception as e:
        # Контролируемый возврат ошибки, чтобы избежать падения Vercel
        print(f"Общая внутренняя ошибка в ai_chat: {e}")
        return jsonify({
            "manager_alert": True,
            "response": f"Произошла внутренняя ошибка сервера. Код: {e}"
        }), 500 

# -----------------------------------------------------------------
# 4. ОБРАБОТЧИК ДЛЯ VERCEL
# -----------------------------------------------------------------

# Этот код необходим для локального тестирования и, косвенно, для Vercel
if __name__ == '__main__':
    # ВНИМАНИЕ: Если вы используете Vercel, он не запустит эту часть. 
    # Он найдет 'app' по конфигурации в vercel.json.
    app.run(debug=True)
